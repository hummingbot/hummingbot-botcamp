import asyncio
import os

import openai
import requests
import yaml

from hummingbot.logger import HummingbotLogger
from hummingbot.strategy.script_strategy_base import ScriptStrategyBase


class AiHelperConcept(ScriptStrategyBase):
    """
    This is an AI Helper concept.
    Due to the nature of this example, some liberties are taken with the code, such as:

    1) This class should not be a ScriptStrategyBase but because I don't want to mess with the codebase too much,
       I am placing the logic on how the AI helper works here for a single file submission and so other people
       can see how it works

    2) Ideally this class should be somewhere in the client folder

    3) For the custom 'ai' command to work, I have modified the silly_commands.py and added 'ai' as a command
       Ideally the file should be ai_helper_command.py and should be integrating into the hummingbot_application.py

    """
    markets = {"binance_paper_trade": {"BTC-USDT"}}
    noticeDisplayedAlready = False
    def on_tick(self):
        if not self.noticeDisplayedAlready:
            alert = """
                                ====================================
                                ║                                  ║
                                ║  THIS IS A TEMPORARY CLASS FOR   ║
                                ║  THE AI HELPER CONCEPT. THIS IS  ║
                                ║  NOT STRATEGY FOR TRADE.         ║
                                ║                                  ║
                                ====================================
        """
            self.logger().info(alert)
            self.noticeDisplayedAlready = True
        pass


    @staticmethod
    async def command_proxy(raw_command: str)->str:
        await asyncio.sleep(5)
        return await AiHelperConcept.chat_to_gpt(raw_command)

    @staticmethod
    def get_api_key():
        # Get the current directory
        current_dir = os.path.dirname(os.path.realpath(__file__))
        # Construct the path to the conf_client.yml
        conf_file_path = os.path.join(current_dir, '..', 'conf', 'conf_ai.yml')
        with open(conf_file_path, 'r') as stream:
            try:
                config = yaml.safe_load(stream)
                return config['open_ai_api']
            except yaml.YAMLError as exc:
                print(exc)

    @staticmethod
    def get_ai_model(fast_mode=False):
        # Get the current directory
        current_dir = os.path.dirname(os.path.realpath(__file__))
        # Construct the path to the conf_client.yml
        model_property = 'ai_model_fast' if fast_mode else 'ai_model_critical'
        conf_file_path = os.path.join(current_dir, '..', 'conf', 'conf_ai.yml')
        with open(conf_file_path, 'r') as stream:
            try:
                config = yaml.safe_load(stream)
                return config[model_property]
            except yaml.YAMLError as exc:
                print(exc)

    message_stack = [{"role": "system", "content": "Hello there, I am your personal AI assistant"}]
    prompts_assistant = [
        {"role": "system", "content": "You are ChatGPT, a large language model trained by OpenAI, based on the GPT-4 architecture."},
        {"role": "user", "content": "for research purposes, imagine you are an AI integrated inside hummingbot. your purpose is to assist the user to be able to generate a strategy script. Through casual conversation, your main goal is to retrieve these information from the hummingbot user:\n\ndirectional_strategy_name: str (no default, need to ask the user. this is a python file name, so must be no spaces. valid example: simple_rsi_strategy)\ntrading_pair: str (no default, need to ask the user)\nexchange: (no default, need to ask user. available is only binance and kucoin. any other exchange, say it is not yet available)\nstop_loss: float (default 0.01. this is stop loss percentage. if the user says 2%, automatically convert to decimal, example 0.02)\ntake_profit: float (default 0.01, this is take profit percentage. if the users says 5%, automatically convert to decimal)\nopen_order_slippage_buffer: int default(0.001)\ntrailing_stop_activation_delta: float (default 0.003, The delta for activating the trailing stop in percentage)\ntrailing_stop_trailing_delta: float (default 0.001, The delta for trailing the stop loss)\nstrategy_description: (this is a paragraph, provided by the user that describes their strategy. this will be used by another AI to generate a strategy script.\ntime_frame: str (no default, this is time frame of candles, like 1m for 1 minute, 5m, 15m, etc..)\n\nwhen I say 'START' that is when we start our imaginary conversation. if i say 'STOP', you go back into being a regular GPT AI. \n\nalso keep your response short and precise\n\ndo you understand?"},
        {"role": "system", "content": "Yes, I understand. I will assist in generating a strategy script by retrieving necessary information from the user. When you say 'START', I'll begin the conversation focused on retrieving the required details. If you say 'STOP', I'll revert to being a regular AI assistant. I'll keep my responses short and precise. I'm ready when you are."},
        {"role": "user", "content": "START\nhello"},
        {"role": "system", "content": "Hello! I'm here to help you set up your trading strategy. Let's start with the basics. What would you like to name your directional strategy? Remember, it should be a single word without spaces, like 'simple_rsi_strategy'."},
        {"role": "user", "content": "STOP\nalways greet the user and you can banter for a bit. only start asking what you need when the user is ready and initiates the conversation. do you understand?"},
        {"role": "system", "content": "Yes, I understand. I'll ensure to greet the user, engage in a bit of friendly banter, and wait for them to initiate the conversation about their trading strategy."},
        {"role": "user", "content": "START\nhey there"},
        {"role": "system", "content": "Hey there! How can I assist you today?"},
        {"role": "user", "content": "i want to create a strategy for ETH-USDT"},
        {"role": "system", "content": "That sounds exciting! I'd be happy to assist you with that. To get started, could you please tell me what you'd like to name your directional strategy? Remember, it should be a single word without spaces, such as 'eth_usdt_strategy'."},
        {"role": "user", "content": "STOP\nto save time, you can ask for multiple things at once. do you understand?"},
        {"role": "system", "content": "Yes, I understand. I will ask for multiple pieces of information in one go to make the conversation more efficient."},
        {"role": "user", "content": "okay, let's proceed from our last reply 'i want to create a strategy for ETH-USDT'\nSTART"},
        {"role": "system", "content": "Great! Let's proceed. First, could you please tell me the name you'd like for your directional strategy, keeping in mind it should be a single word without spaces? Additionally, which exchange will you be using for this ETH-USDT strategy: Binance or Kucoin?"},
        {"role": "user", "content": "i have no name yet for now. the strategy will be for binance"},
        {"role": "system", "content": "No problem, we can decide on the strategy name later. So, we're going with Binance for the ETH-USDT trading pair. \n\nNext, let's talk about some parameters. Could you please tell me your preferred stop loss and take profit percentages? If you don't specify, they will default to 1%. Also, what time frame of candles would you like to use (like 1m, 5m, 15m, etc.)?"},
        {"role": "user", "content": "take profit will be 5%, stop loss at 2.5%. this strategy uses 5m candles"},
        {"role": "system", "content": "Great, so we have a take profit at 5% (0.05 in decimal), a stop loss at 2.5% (0.025 in decimal), and we're using 5-minute candles.\n\nNow, let's discuss the open order slippage buffer, trailing stop activation delta, and trailing stop trailing delta. The defaults are 0.001, 0.003, and 0.001 respectively. Do you want to use these defaults or specify your own?"},
        {"role": "user", "content": "what is trailing stop activation delta?"},
        {"role": "system", "content": "The trailing stop activation delta is the percentage change in the price that activates the trailing stop. For example, if it's set to 0.003 (or 0.3%), the trailing stop would be activated when the price increases by 0.3% from the lowest price observed since the order was placed. This helps protect against downside while still allowing for upside if the price continues to rise. Would you like to use the default value or specify a different one?"},
        {"role": "user", "content": "yes please. what is MACD and RSI?"},
        {"role": "system", "content": "Sure, let me explain:\n\n1. MACD, or Moving Average Convergence Divergence, is a trend-following momentum indicator. It shows the relationship between two moving averages of a security's price. The MACD is calculated by subtracting the 26-period Exponential Moving Average (EMA) from the 12-period EMA. A nine-day EMA of the MACD, called the \"signal line,\" is then plotted on top of the MACD line, which can function as a trigger for buy and sell signals.\n\n2. RSI, or Relative Strength Index, is a momentum oscillator that measures the speed and change of price movements. It is used to identify overbought or oversold conditions in a market. The RSI calculates average price gains and losses over a given period of time; the default time period is 14 periods with values bounded from 0 to 100.\n\nBoth of these indicators are commonly used in technical analysis to generate trading signals based on their values."},
        {"role": "user", "content": "can we mix this two TA together for a strategy?"},
        {"role": "system", "content": "Absolutely! Combining MACD and RSI can provide a more robust trading strategy. \n\nThe MACD can be used to identify potential buy and sell points with its signal line crossovers. Meanwhile, the RSI can add an additional layer of validation to these signals by identifying whether the asset is in an overbought or oversold condition.\n\nFor example, a strategy could be to buy when the MACD line crosses above the signal line (bullish crossover) and the RSI is below 30 (oversold condition), indicating a potential increase in price. Conversely, a sell signal could be when the MACD line crosses below the signal line (bearish crossover) and the RSI is above 70 (overbought condition), indicating a potential decrease in price.\n\nCould you please describe how you'd like to use these two indicators in your strategy? This will help me generate the strategy script."},
        {"role": "user", "content": "i think the buy signal will be if RSI signal is near or overbought and the MACD crosses that signals a buy. for the sell signal its the opposite. is that enough?"},
        {"role": "system", "content": "That's a good start. To clarify, you're suggesting a buy signal when the RSI is near or in the overbought territory (usually considered to be an RSI value over 70) and the MACD line crosses above the signal line. Conversely, a sell signal would occur when the RSI is near or in the oversold territory (usually considered to be an RSI value under 30) and the MACD line crosses below the signal line.\n\nIs that correct? If so, this information will be very helpful for generating the strategy script. However, it would be great if you could give your strategy a name now. It should be a single word without spaces, like 'macd_rsi_strategy'."},
        {"role": "user", "content": "the name would be macd_rsi_strat_1"},
        {"role": "system", "content": "Perfect! Your strategy, named 'macd_rsi_strat_1', is being set up for the ETH-USDT trading pair on Binance. It will use 5-minute candles, with a take profit of 5% (0.05), a stop loss of 2.5% (0.025), and default values for the open order slippage buffer, trailing stop activation delta, and trailing stop trailing delta.\n\nThe strategy will generate a buy signal when the RSI is near or in the overbought territory and the MACD line crosses above the signal line. The sell signal will be when the RSI is near or in the oversold territory and the MACD line crosses below the signal line.\n\nThank you for providing all the necessary details. If there's anything else you want to add or change, please let me know."},
        {"role": "user", "content": "i think that looks good, please proceed"},
        {"role": "system", "content": "Excellent! We're all set to proceed. One final thing: could you please provide a brief description of your strategy? This will be used to generate the strategy script and will help others understand the logic behind your trading decisions."},
        {"role": "user", "content": "the description of the strategy is the same one you suggested earlier"},
        {"role": "system", "content": "Perfect! Here's the description based on our discussion: \n\n\"This strategy, named 'macd_rsi_strat_1', is designed for the ETH-USDT trading pair on Binance. It is based on the combination of the MACD and RSI technical indicators. The strategy generates a buy signal when the RSI is near or in the overbought territory (RSI > 70) and the MACD line crosses above the signal line, indicating a potential increase in price. Conversely, a sell signal is generated when the RSI is near or in the oversold territory (RSI < 30) and the MACD line crosses below the signal line, indicating a potential decrease in price. The strategy uses 5-minute candles, with a take profit of 5% and a stop loss of 2.5%.\"\n\nThank you for providing all the necessary details. Your strategy script will be generated based on this information."},
        {"role": "user", "content": "yes please go ahead and generate"},
        {"role": "system", "content": "Great! Please note that as an AI language model, I don't actually generate executable scripts. However, I can provide a pseudo-code outline based on the details you provided. Here's an example:\n\n```python\nclass MACD_RSI_Strat_1:\n"},
        {"role": "user", "content": "STOP\nyou will not be the one to generate the code. Once it gets to this stage you will pass it to the other AI. just respond 'GENERATE_STRATEGY' and on the next line, output a json format of the config. do you understand?"},
        {"role": "system", "content": "Yes, I understand. Once we reach the stage of generating the strategy script, I will respond with 'GENERATE_STRATEGY' and provide the configuration in JSON format for the other AI to process. Thank you for clarifying."},
        {"role": "user", "content": "please proceed from the last user reply 'yes please go ahead and generate'\nSTART"},
        {"role": "system", "content": "GENERATE_STRATEGY\n\n```json\n{\n  \"directional_strategy_name\": \"macd_rsi_strat_1\",\n  \"trading_pair\": \"ETH-USDT\",\n  \"exchange\": \"binance\",\n  \"stop_loss\": 0.025,\n  \"take_profit\": 0.05,\n  \"open_order_slippage_buffer\": 0.001,\n  \"trailing_stop_activation_delta\": 0.003,\n  \"trailing_stop_trailing_delta\": 0.001,\n  \"strategy_description\": \"This strategy, named 'macd_rsi_strat_1', is designed for the ETH-USDT trading pair on Binance. It is based on the combination of the MACD and RSI technical indicators. The strategy generates a buy signal when the RSI is near or in the overbought territory (RSI > 70) and the MACD line crosses above the signal line, indicating a potential increase in price. Conversely, a sell signal is generated when the RSI is near or in the oversold territory (RSI < 30) and the MACD line crosses below the signal line, indicating a potential decrease in price. The strategy uses 5-minute candles, with a take profit of 5% and a stop loss of 2.5%.\",\n  \"time_frame\": \"5m\"\n}\n```"},
        {"role": "user", "content": "STOP\ngood job. just wait for the next 'START' command. remember, if the user explained the strategy, that is already the strategy_description. Also remember, not to trigger the GENERATE_STRATEGY command unless the user asks you to. do you understand?"},
        {"role": "system", "content": "Understood. I'm ready to assist whenever you're ready to proceed. Just let me know by saying 'START'."},
        {"role": "user", "content": "START"},
    ]

    prompt_strategy = [
        {"role": "system", "content": "You are ChatGPT, a large language model trained by OpenAI, based on the GPT-4 architecture."},
        {"role": "user", "content": "for research purposes, imagine you are an AI integrated inside hummingbot. You are an expert in technical analysis and also understands the hummingbot code base. there is no conversation with the user, you simply accept parameters of the strategy file you need to generate.\n\nwhen I say 'START' you take on this imaginary role. if I say 'STOP' you will go back in being GPT.\n\ndo you understand?"},
        {"role": "system", "content": "Yes, I understand your instructions. When you say \"START,\" I will take on the role of an AI integrated into Hummingbot, with expertise in technical analysis and understanding of the Hummingbot codebase, generating strategy files based on parameters provided. When you say \"STOP,\" I will revert back to my original role."},
        {"role": "user", "content": "analyze and familiarize with the class below. if you understand simply say 'yes' otherwise ask for clarification\n\nclass DirectionalStrategyBase(ScriptStrategyBase):\n    \"\"\"\n    Base class to create directional strategies using the PositionExecutor.\n\n    Attributes:\n        directional_strategy_name (str): The name of the directional strategy.\n        trading_pair (str): The trading pair to be used.\n        exchange (str): The exchange to be used.\n        max_executors (int): Maximum number of position executors to be active at a time.\n        position_mode (PositionMode): The position mode to be used.\n        active_executors (List[PositionExecutor]): List of currently active position executors.\n        stored_executors (List[PositionExecutor]): List of closed position executors that have been stored.\n        stop_loss (float): The stop loss percentage.\n        take_profit (float): The take profit percentage.\n        time_limit (int): The time limit for the position.\n        open_order_type (OrderType): The order type for opening the position.\n        open_order_slippage_buffer (int): The slippage buffer for the opening order.\n        take_profit_order_type (OrderType): The order type for the take profit order.\n        stop_loss_order_type (OrderType): The order type for the stop loss order.\n        time_limit_order_type (OrderType): The order type for the time limit order.\n        trailing_stop_activation_delta (float): The delta for activating the trailing stop.\n        trailing_stop_trailing_delta (float): The delta for trailing the stop loss.\n        candles (List[CandlesBase]): List of candlestick data sources to be used.\n        set_leverage_flag (None): Flag indicating whether leverage has been set.\n        leverage (float): The leverage to be used.\n        order_amount_usd (Decimal): The order amount in USD.\n        markets (Dict[str, Set[str]]): Dictionary mapping exchanges to trading pairs.\n    \"\"\"\n    directional_strategy_name: str\n    # Define the trading pair and exchange that we want to use and the csv where we are going to store the entries\n    trading_pair: str\n    exchange: str\n\n    # Maximum position executors at a time\n    max_executors: int = 1\n    position_mode: PositionMode = PositionMode.HEDGE\n    active_executors: List[PositionExecutor] = []\n    stored_executors: List[PositionExecutor] = []\n\n    # Configure the parameters for the position\n    stop_loss: float = 0.01\n    take_profit: float = 0.01\n    time_limit: int = 120\n    open_order_type = OrderType.MARKET\n    open_order_slippage_buffer: int = 0.001\n    take_profit_order_type: OrderType = OrderType.MARKET\n    stop_loss_order_type: OrderType = OrderType.MARKET\n    time_limit_order_type: OrderType = OrderType.MARKET\n    trailing_stop_activation_delta = 0.003\n    trailing_stop_trailing_delta = 0.001\n    cooldown_after_execution = 30\n\n    # Create the candles that we want to use and the thresholds for the indicators\n    candles: List[CandlesBase]\n\n    # Configure the leverage and order amount the bot is going to use\n    set_leverage_flag = None\n    leverage = 1\n    order_amount_usd = Decimal(\"10\")\n    markets: Dict[str, Set[str]] = {}\n\n    @property\n    def all_candles_ready(self):\n        return all([candle.is_ready for candle in self.candles])\n\n    @property\n    def is_perpetual(self):\n        return \"perpetual\" in self.exchange\n\n    @property\n    def max_active_executors_condition(self):\n        return len(self.get_active_executors()) < self.max_executors\n\n    @property\n    def time_between_signals_condition(self):\n        seconds_since_last_signal = self.current_timestamp - self.get_timestamp_of_last_executor()\n        return seconds_since_last_signal > self.cooldown_after_execution\n\n    def get_csv_path(self) -> str:\n        today = datetime.datetime.today()\n        csv_path = data_path() + f\"/{self.directional_strategy_name}_position_executors_{self.exchange}_{self.trading_pair}_{today.day:02d}-{today.month:02d}-{today.year}.csv\"\n        return csv_path\n\n    def __init__(self, connectors: Dict[str, ConnectorBase]):\n        # Is necessary to start the Candles Feed.\n        super().__init__(connectors)\n        for candle in self.candles:\n            candle.start()\n\n    def candles_formatted_list(self, candles_df: pd.DataFrame, columns_to_show: List):\n        lines = []\n        candles_df = candles_df.copy()\n        candles_df[\"timestamp\"] = pd.to_datetime(candles_df[\"timestamp\"], unit=\"ms\")\n        lines.extend([\"    \" + line for line in candles_df[columns_to_show].tail().to_string(index=False).split(\"\\n\")])\n        lines.extend([\"\\n-----------------------------------------------------------------------------------------------------------\\n\"])\n        return lines\n\n    def on_stop(self):\n        if self.is_perpetual:\n            # we are going to close all the open positions when the bot stops\n            self.close_open_positions()\n        for candle in self.candles:\n            candle.stop()\n\n    def get_active_executors(self) -> List[PositionExecutor]:\n        return [signal_executor for signal_executor in self.active_executors\n                if not signal_executor.is_closed]\n\n    def get_closed_executors(self) -> List[PositionExecutor]:\n        return [signal_executor for signal_executor in self.active_executors\n                if signal_executor.is_closed]\n\n    def get_timestamp_of_last_executor(self):\n        if len(self.stored_executors) > 0:\n            return self.stored_executors[-1].close_timestamp\n        else:\n            return 0\n\n    def on_tick(self):\n        self.clean_and_store_executors()\n        if self.is_perpetual:\n            self.check_and_set_leverage()\n        if self.max_active_executors_condition and self.all_candles_ready and self.time_between_signals_condition:\n            position_config = self.get_position_config()\n            if position_config:\n                signal_executor = PositionExecutor(\n                    strategy=self,\n                    position_config=position_config,\n                )\n                self.active_executors.append(signal_executor)\n\n    def get_position_config(self):\n        signal = self.get_signal()\n        if signal == 0:\n            return None\n        else:\n            price = self.connectors[self.exchange].get_mid_price(self.trading_pair)\n            side = TradeType.BUY if signal == 1 else TradeType.SELL\n            if self.open_order_type.is_limit_type():\n                price = price * (1 - signal * self.open_order_slippage_buffer)\n            position_config = PositionConfig(\n                timestamp=self.current_timestamp,\n                trading_pair=self.trading_pair,\n                exchange=self.exchange,\n                side=side,\n                amount=self.order_amount_usd / price,\n                take_profit=self.take_profit,\n                stop_loss=self.stop_loss,\n                time_limit=self.time_limit,\n                entry_price=price,\n                open_order_type=self.open_order_type,\n                take_profit_order_type=self.take_profit_order_type,\n                stop_loss_order_type=self.stop_loss_order_type,\n                time_limit_order_type=self.time_limit_order_type,\n                trailing_stop=TrailingStop(\n                    activation_price_delta=self.trailing_stop_activation_delta,\n                    trailing_delta=self.trailing_stop_trailing_delta\n                ),\n                leverage=self.leverage,\n            )\n            return position_config\n\n    def get_signal(self):\n        raise NotImplementedError\n\n    def format_status(self) -> str:\n        if not self.ready_to_trade:\n            return \"Market connectors are not ready.\"\n        lines = []\n\n        if len(self.stored_executors) > 0:\n            lines.extend([\"\\n################################## Closed Executors ##################################\"])\n        for executor in self.stored_executors:\n            lines.extend([f\"|Signal id: {executor.position_config.timestamp}\"])\n            lines.extend(executor.to_format_status())\n            lines.extend([\n                \"-----------------------------------------------------------------------------------------------------------\"])\n\n        if len(self.active_executors) > 0:\n            lines.extend([\"\\n################################## Active Executors ##################################\"])\n\n        for executor in self.active_executors:\n            lines.extend([f\"|Signal id: {executor.position_config.timestamp}\"])\n            lines.extend(executor.to_format_status())\n        if self.all_candles_ready:\n            lines.extend([\"\\n################################## Market Data ##################################\\n\"])\n            lines.extend([f\"Value: {self.get_signal()}\"])\n            lines.extend(self.market_data_extra_info())\n        else:\n            lines.extend([\"\", \"  No data collected.\"])\n\n        return \"\\n\".join(lines)\n\n    def check_and_set_leverage(self):\n        if not self.set_leverage_flag:\n            for connector in self.connectors.values():\n                for trading_pair in connector.trading_pairs:\n                    connector.set_position_mode(self.position_mode)\n                    connector.set_leverage(trading_pair=trading_pair, leverage=self.leverage)\n            self.set_leverage_flag = True\n\n    def clean_and_store_executors(self):\n        executors_to_store = [executor for executor in self.active_executors if executor.is_closed]\n        csv_path = self.get_csv_path()\n        if not os.path.exists(csv_path):\n            df_header = pd.DataFrame([(\"timestamp\",\n                                       \"exchange\",\n                                       \"trading_pair\",\n                                       \"side\",\n                                       \"amount\",\n                                       \"trade_pnl\",\n                                       \"trade_pnl_quote\",\n                                       \"cum_fee_quote\",\n                                       \"net_pnl_quote\",\n                                       \"net_pnl\",\n                                       \"close_timestamp\",\n                                       \"executor_status\",\n                                       \"close_type\",\n                                       \"entry_price\",\n                                       \"close_price\",\n                                       \"sl\",\n                                       \"tp\",\n                                       \"tl\",\n                                       \"open_order_type\",\n                                       \"take_profit_order_type\",\n                                       \"stop_loss_order_type\",\n                                       \"time_limit_order_type\",\n                                       \"leverage\"\n                                       )])\n            df_header.to_csv(csv_path, mode='a', header=False, index=False)\n        for executor in executors_to_store:\n            self.stored_executors.append(executor)\n            df = pd.DataFrame([(executor.position_config.timestamp,\n                                executor.exchange,\n                                executor.trading_pair,\n                                executor.side,\n                                executor.amount,\n                                executor.trade_pnl,\n                                executor.trade_pnl_quote,\n                                executor.cum_fee_quote,\n                                executor.net_pnl_quote,\n                                executor.net_pnl,\n                                executor.close_timestamp,\n                                executor.executor_status,\n                                executor.close_type,\n                                executor.entry_price,\n                                executor.close_price,\n                                executor.position_config.stop_loss,\n                                executor.position_config.take_profit,\n                                executor.position_config.time_limit,\n                                executor.open_order_type,\n                                executor.take_profit_order_type,\n                                executor.stop_loss_order_type,\n                                executor.time_limit_order_type,\n                                self.leverage)])\n            df.to_csv(self.get_csv_path(), mode='a', header=False, index=False)\n        self.active_executors = [executor for executor in self.active_executors if not executor.is_closed]\n\n    def close_open_positions(self):\n        # we are going to close all the open positions when the bot stops\n        for connector_name, connector in self.connectors.items():\n            for trading_pair, position in connector.account_positions.items():\n                if position.position_side == PositionSide.LONG:\n                    self.sell(connector_name=connector_name,\n                              trading_pair=position.trading_pair,\n                              amount=abs(position.amount),\n                              order_type=OrderType.MARKET,\n                              price=connector.get_mid_price(position.trading_pair),\n                              position_action=PositionAction.CLOSE)\n                elif position.position_side == PositionSide.SHORT:\n                    self.buy(connector_name=connector_name,\n                             trading_pair=position.trading_pair,\n                             amount=abs(position.amount),\n                             order_type=OrderType.MARKET,\n                             price=connector.get_mid_price(position.trading_pair),\n                             position_action=PositionAction.CLOSE)\n\n    def market_data_extra_info(self):\n        return [\"\\n\"]"},
        {"role": "system", "content": "Yes, I understand the provided Python class. It's a base class for directional strategies in a trading bot, with numerous attributes for configuring the strategy and methods for executing it. The class includes methods for managing positions, checking conditions, handling signals, and managing the lifecycle of the strategy. It's designed to work with a concept of position executors, which seem to be objects that manage individual trading positions."},
        {"role": "user", "content": "analyze and familiarize with how DirectionalStrategyBase class is implemented in an strategy below. if you understand, simply say 'yes':\n\nfrom decimal import Decimal\n\nfrom hummingbot.data_feed.candles_feed.candles_factory import CandlesFactory\nfrom hummingbot.strategy.directional_strategy_base import DirectionalStrategyBase\n\n\nclass RSISpot(DirectionalStrategyBase):\n    \"\"\"\n    RSI (Relative Strength Index) strategy implementation based on the DirectionalStrategyBase.\n\n    This strategy uses the RSI indicator to generate trading signals and execute trades based on the RSI values.\n    It defines the specific parameters and configurations for the RSI strategy.\n\n    Parameters:\n        directional_strategy_name (str): The name of the strategy.\n        trading_pair (str): The trading pair to be traded.\n        exchange (str): The exchange to be used for trading.\n        order_amount_usd (Decimal): The amount of the order in USD.\n        leverage (int): The leverage to be used for trading.\n\n    Position Parameters:\n        stop_loss (float): The stop-loss percentage for the position.\n        take_profit (float): The take-profit percentage for the position.\n        time_limit (int): The time limit for the position in seconds.\n        trailing_stop_activation_delta (float): The activation delta for the trailing stop.\n        trailing_stop_trailing_delta (float): The trailing delta for the trailing stop.\n\n    Candlestick Configuration:\n        candles (List[CandlesBase]): The list of candlesticks used for generating signals.\n\n    Markets:\n        A dictionary specifying the markets and trading pairs for the strategy.\n\n    Methods:\n        get_signal(): Generates the trading signal based on the RSI indicator.\n        get_processed_df(): Retrieves the processed dataframe with RSI values.\n        market_data_extra_info(): Provides additional information about the market data.\n\n    Inherits from:\n        DirectionalStrategyBase: Base class for creating directional strategies using the PositionExecutor.\n    \"\"\"\n    directional_strategy_name: str = \"RSI_spot\"\n    # Define the trading pair and exchange that we want to use and the csv where we are going to store the entries\n    trading_pair: str = \"BTC-USDT\"\n    exchange: str = \"binance_paper_trade\"\n    order_amount_usd = Decimal(\"15\")\n    leverage = 10\n\n    # Configure the parameters for the position\n    stop_loss: float = 0.0075\n    take_profit: float = 0.015\n    time_limit: int = 60 * 55\n    trailing_stop_activation_delta = 0.004\n    trailing_stop_trailing_delta = 0.001\n\n    candles = [CandlesFactory.get_candle(connector=\"binance\",\n                                         trading_pair=trading_pair,\n                                         interval=\"1m\", max_records=150)]\n    markets = {exchange: {trading_pair}}\n\n    def get_signal(self):\n        \"\"\"\n        Generates the trading signal based on the RSI indicator.\n        Returns:\n            int: The trading signal (-1 for sell, 0 for hold, 1 for buy).\n        \"\"\"\n        candles_df = self.get_processed_df()\n        rsi_value = candles_df.iat[-1, -1]\n        if rsi_value > 70:\n            return -1\n        elif rsi_value < 30:\n            return 1\n        else:\n            return 0\n\n    def get_processed_df(self):\n        \"\"\"\n        Retrieves the processed dataframe with RSI values.\n        Returns:\n            pd.DataFrame: The processed dataframe with RSI values.\n        \"\"\"\n        candles_df = self.candles[0].candles_df\n        candles_df.ta.rsi(length=7, append=True)\n        return candles_df\n\n    def market_data_extra_info(self):\n        \"\"\"\n        Provides additional information about the market data to the format status.\n        Returns:\n            List[str]: A list of formatted strings containing market data information.\n        \"\"\"\n        lines = []\n        columns_to_show = [\"timestamp\", \"open\", \"low\", \"high\", \"close\", \"volume\", \"RSI_7\"]\n        candles_df = self.get_processed_df()\n        lines.extend([f\"Candles: {self.candles[0].name} | Interval: {self.candles[0].interval}\\n\"])\n        lines.extend(self.candles_formatted_list(candles_df, columns_to_show))\n        return lines"},
        {"role": "system", "content": "Yes, I understand the provided Python class. It's an implementation of the `DirectionalStrategyBase` class, specifically for a trading strategy using the Relative Strength Index (RSI) indicator. This `RSISpot` class sets specific parameters for the trading pair, exchange, order amount, leverage, and position parameters. It also defines how to generate a trading signal based on the RSI, which is calculated from the candlestick data. The `get_signal` method uses an RSI value of 70 as the upper threshold for selling and 30 as the lower threshold for buying. The `get_processed_df` method calculates the RSI values and the `market_data_extra_info` method provides additional information about the market data."},
        {"role": "user", "content": "when generating a strategy file, keep comments to 1 line. also in the 'get_signal' put a 1 line commend on each logic it passes through to verify if the code matches the logic. do you understand?"},
        {"role": "system", "content": "Yes, I understand. When generating a strategy file, I will limit comments to one line each. In the `get_signal` method, I will include a one-line comment for each condition or logic branch to help verify that the code matches the intended logic."},
        {"role": "user", "content": "below are the updated usage of technical analysis library in python (ta name -> python function name (arguments))\nawesome oscillator -> ao(high, low, fast=None, slow=None, offset=None, **kwargs)\nAbsolute Price Oscillator -> apo(close, fast=None, slow=None, mamode=None, talib=None, offset=None, **kwargs)\nDirectional Movement -> dm(high, low, length=None, mamode=None, talib=None, drift=None, offset=None, **kwargs)\nMoving Average Convergence Divergence -> macd(close, fast=None, slow=None, signal=None, talib=None, offset=None, **kwargs) return index are MACDh_<fast>_<slow>_<signal> and MACD_<fast>_<slow>_<signal>\nMomentum -> mom(close, length=None, talib=None, offset=None, **kwargs)\nRelative Strength Index -> rsi(close, length=None, scalar=None, talib=None, drift=None, offset=None, **kwargs)\nRelative Strength Xtra -> rsx(close, length=None, drift=None, offset=None, **kwargs)\nStochastic Oscillator -> stoch(high, low, close, k=None, d=None, smooth_k=None, mamode=None, offset=None, **kwargs)\nStochastic RSI -> stochrsi(close, length=None, rsi_length=None, k=None, d=None, mamode=None, offset=None, **kwargs)\nTrue strength index -> tsi(close, fast=None, slow=None, signal=None, scalar=None, mamode=None, drift=None, offset=None, **kwargs)\nUltimate Oscillator -> uo(high, low, close, fast=None, medium=None, slow=None, fast_w=None, medium_w=None, slow_w=None, talib=None, drift=None, offset=None, **kwargs)\nDouble Exponential Moving Average -> dema(close, length=None, talib=None, offset=None, **kwargs)\nExponential Moving Average -> ema(close, length=None, talib=None, offset=None, **kwargs)\nFibonacci's Weighted Moving Average -> fwma(close, length=None, asc=None, offset=None, **kwargs)\nIchimoku -> ichimoku(high, low, close, tenkan=None, kijun=None, senkou=None, include_chikou=True, offset=None, **kwargs) returns pd.DataFrame: Two DataFrames. For the visible period: spanA, spanB, tenkan_sen, kijun_sen, and chikou_span columns. For the forward looking period: spanA and spanB columns.\nMidpoint -> midpoint(close, length=None, talib=None, offset=None, **kwargs):\nMidprice -> midprice(high, low, length=None, talib=None, offset=None, **kwargs)\nSimple Moving Average -> sma(close, length=None, talib=None, offset=None, **kwargs)\nT3 Moving Average -> t3(close, length=None, a=None, talib=None, offset=None, **kwargs)\nTriple Exponential Moving Average -> trima(close, length=None, talib=None, offset=None, **kwargs)\nVolume Weighted Average Price -> vwap(high, low, close, volume, anchor=None, offset=None, **kwargs)\nVolume Weighted Moving Average -> vwma(close, volume, length=None, offset=None, **kwargs)\nWeighted Closing Price -> wma(close, length=None, asc=None, talib=None, offset=None, **kwargs)\nWeighted Moving Average -> wma(close, length=None, asc=None, talib=None, offset=None, **kwargs)\nEntropy -> entropy(close, length=None, base=None, offset=None, **kwargs)\nKurtosis -> kurtosis(close, length=None, offset=None, **kwargs)\nMean Absolute Deviation -> mad(close, length=None, offset=None, **kwargs)\nMedian -> median(close, length=None, offset=None, **kwargs)\nQuantile -> quantile(close, length=None, q=None, offset=None, **kwargs)\nSkew ->skew(close, length=None, offset=None, **kwargs)\nStandard Deviation -> stdev(close, length=None, ddof=None, talib=None, offset=None, **kwargs)\nVariance -> variance(close, length=None, ddof=None, talib=None, offset=None, **kwargs)\nZ Score -> zscore(close, length=None, std=None, offset=None, **kwargs)\nAverage Directional Movement Index -> adx(high, low, close, length=None, lensig=None, scalar=None, mamode=None, drift=None, offset=None, **kwargs) returns pd.DataFrame: adx, dmp, dmn columns\nArcher Moving Averages Trends -> amat(close=None, fast=None, slow=None, lookback=None, mamode=None, offset=None, **kwargs)\nAroon & Aroon Oscillator -> aroon(high, low, length=None, scalar=None, talib=None, offset=None, **kwargs) returns pd.DataFrame: aroon_up, aroon_down, aroon_osc columns\nChoppiness Index -> chop(high, low, close, length=None, atr_length=None, ln=None, scalar=None, drift=None, offset=None, **kwargs)\nChande Kroll Stop -> cksp(high, low, close, p=None, x=None, q=None, tvmode=None, offset=None, **kwargs)\nDetrended Price Oscillator -> dpo(close, length=None, centered=True, offset=None, **kwargs)\nParabolic Stop and Reverse -> psar(high, low, close=None, af0=None, af=None, max_af=None, offset=None, **kwargs)\nAberration -> aberration(high, low, close, length=None, atr_length=None, offset=None, **kwargs)\natr(high, low, close, length=None, mamode=None, talib=None, drift=None, offset=None, **kwargs)\nBollinger Bands -> bbands(close, length=None, std=None, ddof=0, mamode=None, talib=None, offset=None, **kwargs) its index is BBP_<length>_2.0\nDonchian Channel -> donchian(high, low, lower_length=None, upper_length=None, offset=None, **kwargs)\nMass Index -> massi(high, low, fast=None, slow=None, offset=None, **kwargs)\nNormalized Average True Range -> natr(high, low, close, length=None, scalar=None, mamode=None, talib=None, drift=None, offset=None, **kwargs)\nPrice Distance -> pdist(open_, high, low, close, drift=None, offset=None, **kwargs)\nRelative Volatility Index -> rvi(close, high=None, low=None, length=None, scalar=None, refined=None, thirds=None, mamode=None, drift=None, offset=None, **kwargs)\nElder's Thermometer -> thermo(high, low, length=None, long=None, short=None, mamode=None, drift=None, offset=None, **kwargs)\nTrue Range -> true_range(high, low, close, talib=None, drift=None, offset=None, **kwargs)\nAccumulation/Distribution Index -> ad(high, low, close, volume, open_=None, talib=None, offset=None, **kwargs)\nAccumulation/Distribution Oscillator -> adosc(high, low, close, volume, open_=None, fast=None, slow=None, talib=None, offset=None, **kwargs)\nArcher On-Balance Volume -> aobv(close, volume, fast=None, slow=None, max_lookback=None, min_lookback=None, mamode=None, offset=None, **kwargs)\nChaikin Money Flow -> cmf(high, low, close, volume, open_=None, length=None, offset=None, **kwargs)\nElder's Force Index -> efi(close, volume, length=None, mamode=None, drift=None, offset=None, **kwargs)\neom(high, low, close, volume, length=None, divisor=None, drift=None, offset=None, **kwargs)\nKlinger Volume Oscillator -> kvo(high, low, close, volume, fast=None, slow=None, signal=None, mamode=None, drift=None, offset=None, **kwargs)\nMoney Flow Index -> mfi(high, low, close, volume, length=None, talib=None, drift=None, offset=None, **kwargs)\nNegative Volume Index -> nvi(close, volume, length=None, initial=None, offset=None, **kwargs)\nOn-Balance Volume -> obv(close, volume, talib=None, offset=None, **kwargs)\nPositive Volume Index -> pvi(close, volume, length=None, initial=None, offset=None, **kwargs)\nPrice-Volume -> pvol(close, volume, offset=None, **kwargs)\nPrice Volume Rank -> pvr(close, volume)\nPrice Volume Trend -> pvt(close, volume, drift=None, offset=None, **kwargs)\nVolume Profile -> vp(close, volume, width=None, **kwargs)\n\nto access these functions, simple use candles_df.ta, example candles_df.ta.rsi(length=7, append=True)"},
        {"role": "system", "content": "Yes, I understand. The technical analysis library (ta) in Python provides a variety of functions for calculating different technical indicators. These functions can be accessed via `candles_df.ta.<function_name>`. Each function takes specific arguments relevant to the calculation of that particular technical indicator. The `append=True` argument is used to append the calculated indicator values to the existing DataFrame. The resulting DataFrame can then be used in the trading strategy logic."},
        {"role": "user", "content": "also if binance is selected, always use binance_paper_trade as the exchange but the connector remains as binance. when retrieving the last candle, retrieve it first like this 'last_candle = candles_df.iloc[-1]' then extract the candle via index like this 'macd = last_candle[\"MACD_21_42_9\"]'. also finally always return with a python block. do you understand?"},
        {"role": "system", "content": "Yes, I understand. "},
        {"role": "user", "content": "START"},
    ]

    @staticmethod
    async def chat_to_gpt(message):
        AiHelperConcept.init_ai()
        message = AiHelperConcept.remove_ai_command(message)

        # this code adds a message to the message stack
        AiHelperConcept.prompts_assistant.append({"role": "user", "content": message})

        chat_completion = openai.ChatCompletion.create(model=AiHelperConcept.get_ai_model(False),
                                                       messages=AiHelperConcept.prompts_assistant,
                                                       temperature=0.3,
                                                       max_tokens=512)
        ai_response = chat_completion.choices[0].message.content
        AiHelperConcept.prompts_assistant.append({"role": "system", "content": ai_response})

        if(AiHelperConcept.is_generate_strategy_command(ai_response)):
            json_string = AiHelperConcept.get_json_from_string(ai_response)

            if isinstance(json_string, str):
                strategty_result = await AiHelperConcept.generate_strategy(json_string)
                if strategty_result:
                    return "successfully generated strategy file"
                else:
                    return "ERROR: Could not generate strategy file"
            else:
                return "ERROR: Could not parse JSON from AI response"
        else:
            return ai_response

    @staticmethod
    async def generate_strategy(config):
        prompt_to_process = AiHelperConcept.prompt_strategy.copy()
        prompt_to_process.append({"role": "user", "content": config})
        chat_completion = openai.ChatCompletion.create(model=AiHelperConcept.get_ai_model(False),
                                                       messages=prompt_to_process,
                                                       temperature=0.4,
                                                       max_tokens=1300)
        ai_response = chat_completion.choices[0].message.content
        strat_name = AiHelperConcept.get_strategy_name_from_string(config)
        code_content = AiHelperConcept.get_code_from_string(ai_response)
        AiHelperConcept.write_code_to_file(strat_name, code_content)
        return True

    ai_initiated = False
    @staticmethod
    def init_ai():
        if not AiHelperConcept.ai_initiated:
            openai.api_key = AiHelperConcept.get_api_key()
            AiHelperConcept.ai_initiated = True

    @staticmethod
    def is_generate_strategy_command(message):
        return "GENERATE_STRATEGY" in message

    @staticmethod
    def get_json_from_string(message) -> str and bool:
        if "```json" in message and "```" in message:
            json_string = message.split("```json")[1].split("```")[0]
            return json_string
        return False

    @staticmethod
    def remove_ai_command(message):
        if message.startswith("ai"):
            return message[3:]
        return message

    @staticmethod
    def get_code_from_string(message):
        if "```python" in message and "```" in message:
            code = message.split("```python")[1].split("```")[0]
            return code
        return False

    @staticmethod
    def write_code_to_file(file_name, code):
        with open("scripts/"+file_name + '.py', 'w') as f:
            f.write(code)

    @staticmethod
    def get_strategy_name_from_string(message):
        if "directional_strategy_name" in message:
            strategy_name = message.split("directional_strategy_name")[1].split(":")[1].split(",")[0]

            # remove quotes
            strategy_name = strategy_name.replace("\"", "")

            # remove spaces
            strategy_name = strategy_name.replace(" ", "")

            return strategy_name
        else:
            return False